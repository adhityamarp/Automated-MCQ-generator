# -*- coding: utf-8 -*-
"""Untitled26.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZoE7W78RcEJi_giDLCy7ovJAkienVL5R
"""

!pip install PyPDF2
!pip install python-docx
import spacy
import random
import PyPDF2
from docx import Document

nlp = spacy.load("en_core_web_sm")

def extract_keywords(text):
    """Extract significant nouns, proper nouns, and other key terms from the text."""
    doc = nlp(text)
    keywords = [token.text for token in doc if token.pos_ in ("NOUN", "PROPN") and len(token.text) > 2]
    return list(set(keywords))  # Remove duplicates

def generate_distractors(correct_answer, keywords):
    """Generate distractors that are semantically related to the correct answer."""
    distractors = [word for word in keywords if word.lower() != correct_answer.lower()]
    random.shuffle(distractors)
    return distractors[:3]  # Return the top 3 distractors

def generate_mcq_dynamic(text):
    """Generate MCQs with contextually relevant options and varied formats."""
    keywords = extract_keywords(text)
    doc = nlp(text)
    questions = []

    for sentence in doc.sents:
        # --- Improved question generation logic ---
        if "is" in sentence.text or "are" in sentence.text:
            question_formats = [
                lambda ans, sent: sent.text.replace(ans, "_____"),  # Fill-in-the-blanks
                # Check if splitting by 'is' results in at least 2 elements before accessing index 1
                lambda ans, sent: f"What is {sent.text.split('is')[1].strip()}?" if len(sent.text.split('is')) > 1 else sent.text.replace(ans, "_____"), # What is...? format or fallback to fill-in-the-blanks
                # Check if splitting by 'is' results in at least 2 elements before accessing index 0 and replacing
                lambda ans, sent: f"Which of the following is {sent.text.split('is')[0].strip().replace(ans.strip(),'')}?" if len(sent.text.split('is')) > 1 else sent.text.replace(ans, "_____")  # Which of the following is...? format or fallback to fill-in-the-blanks
                # Add more formats as needed
            ]

            correct_answer = next((word for word in keywords if word in sentence.text), None)
            if correct_answer:
                distractors = generate_distractors(correct_answer, keywords)
                # Select a question format randomly
                question_format = random.choice(question_formats)
                questions.append({
                    "question": question_format(correct_answer, sentence),
                    "correct_answer": correct_answer,
                    "options": [correct_answer] + distractors
                })
    return questions

def display_questions_dynamic(questions, num_questions):
    """Display a limited number of questions with dynamic options."""
    selected_questions = random.sample(questions, min(num_questions, len(questions)))
    score = 0

    for i, q in enumerate(selected_questions, 1):
        print(f"Q{i}: {q['question']}")
        options = random.sample(q['options'], len(q['options']))  # Shuffle options
        for j, option in enumerate(options, 1):
            print(f"   {j}. {option}")
        try:
            answer = int(input("Your answer (enter option number): "))
            if options[answer - 1] == q['correct_answer']:
                score += 1
                print("Correct!")
            else:
                print(f"Incorrect. The correct answer is: {q['correct_answer']}")
        except (ValueError, IndexError):
            print("Invalid input! Moving to the next question.")
    return score, len(selected_questions)

def extract_text_from_docx(file_path):
    """Extracts text from a DOCX file using python-docx."""
    doc = Document(file_path)
    text = ""
    for paragraph in doc.paragraphs:
        text += paragraph.text + "\n"
    return text

if __name__ == "__main__":
    file_path = input("Enter the path to your PDF or DOCX file: ")  # Get input from the user

    # Extract text based on file type
    if file_path.endswith(".pdf"):
        text = extract_text_from_pdf(file_path) # Assigning the result to text variable
    elif file_path.endswith(".docx"):
        text = extract_text_from_docx(file_path) # Assigning the result to text variable
    else:
        print("Unsupported file type! Please provide a PDF or DOCX file.")
        exit()

    # Generate MCQs with dynamic options
    questions = generate_mcq_dynamic(text)
    print(f"{len(questions)} questions generated.")

    # Allow user to select the number of questions
    num_questions = int(input("Enter the number of questions you want to attempt: ")) # Get input for num_questions
    score, total = display_questions_dynamic(questions, num_questions)
    print(f"You scored {score}/{total}")

